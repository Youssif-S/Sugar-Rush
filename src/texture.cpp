#include "TextureBuilder.h"
#include "Model_3DS.h"
#include "glut.h"
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <vector>
#include <string>
#include <windows.h> // For sound

// Define GL_BGR if not already defined (needed for texture loading)
#ifndef GL_BGR
#define GL_BGR 0x80E0
#endif

// Define PI for trigonometric calculations
#define PI 3.14159265358979323846

// --- Texture loading helpers (new) ---
// Global variables to store texture IDs generated by OpenGL
static GLuint grassTexture = 0;
static GLuint roadTexture = 0;
static GLuint cakeTexture = 0;
static GLuint carTexture = 0; // Red car texture
static GLuint blueCarTexture = 0; // Blue car texture for level 2
static GLuint vendingCartTexture = 0; // Ice cream cart texture
static GLuint snowTexture = 0; // Snow ground texture for level 2
static GLuint gumballTexture = 0; // Gumball machine texture for level 2
static GLuint cakePopTexture = 0; // Cake pop texture for level 2
static GLuint skyTexture = 0; // Sky texture
static GLuint finishLineTexture = 0; // Finish line texture
static GLuint gummyTexture = 0; // Gummy bear texture
static GLuint candyCaneTexture = 0; // Candy cane texture

// Nearest-neighbor resize from src(w*h*3 BGR) to dst(newW*newH*3)
// This function resizes image data to a power of 2 (e.g., 512x512) which is often required by older OpenGL versions
static unsigned char* ResizeNearest(const unsigned char* src, int srcW, int srcH, int dstW, int dstH) {
    // Allocate memory for the destination image (width * height * 3 bytes for RGB)
    unsigned char* dst = (unsigned char*)malloc(dstW * dstH * 3);
    if (!dst) return NULL; // Return NULL if memory allocation fails
    
    // Loop through every pixel in the destination image
    for (int y = 0; y < dstH; ++y) {
        // Calculate the corresponding Y coordinate in the source image
        int sy = (y * srcH) / dstH;
        if (sy >= srcH) sy = srcH - 1; // Clamp to valid range
        
        for (int x = 0; x < dstW; ++x) {
            // Calculate the corresponding X coordinate in the source image
            int sx = (x * srcW) / dstW;
            if (sx >= srcW) sx = srcW - 1; // Clamp to valid range
            
            // Get pointer to the source pixel (3 bytes per pixel: B, G, R)
            const unsigned char* s = src + (sy * srcW + sx) * 3;
            // Get pointer to the destination pixel
            unsigned char* d = dst + (y * dstW + x) * 3;
            
            // Copy pixel data
            d[0] = s[0]; d[1] = s[1]; d[2] = s[2];
        }
    }
    return dst; // Return the resized image data
}

// Load a 24-bit BMP from disk, support padding, bottom-up rows, resample to 512x512 if needed.
// This function reads a BMP file, handles its headers, and creates an OpenGL texture from it.
static GLuint LoadBMPAndCreateGLTexture(const char* path) {
    // Open the file in binary read mode
    FILE* f = fopen(path, "rb");
    if (!f) {
        printf("LoadBMP: failed to open %s\n", path);
        return 0;
    }

    // Read the BMP file header (14 bytes)
    unsigned char fileHeader[14];
    if (fread(fileHeader, 1, 14, f) != 14) { fclose(f); return 0; }
    
    // Check for BMP signature 'B' 'M'
    if (fileHeader[0] != 'B' || fileHeader[1] != 'M') {
        printf("LoadBMP: %s is not a BMP\n", path);
        fclose(f);
        return 0;
    }
    // Get the offset where pixel data starts
    unsigned int dataOffset = *(unsigned int*)&fileHeader[10];

    // Read the BMP info header (40 bytes)
    unsigned char infoHeader[40];
    if (fread(infoHeader, 1, 40, f) != 40) { fclose(f); return 0; }
    
    // Extract width, height, and bit depth
    int width = *(int*)&infoHeader[4];
    int height = *(int*)&infoHeader[8];
    short planes = *(short*)&infoHeader[12];
    short bpp = *(short*)&infoHeader[14];

    // Warn if not 24-bit (standard RGB)
    if (bpp != 24) {
        printf("LoadBMP: %s is not 24-bit (bpp=%d) - attempting to continue\n", path, bpp);
    }

    if (width <= 0 || height == 0) {
        printf("LoadBMP: invalid dimensions %dx%d in %s\n", width, height, path);
        fclose(f);
        return 0;
    }

    // BMP height can be negative (top-down), take absolute value
    int absHeight = (height > 0) ? height : -height;

    // Move file pointer to the start of pixel data
    fseek(f, dataOffset, SEEK_SET);

    // Calculate row size with padding (rows are aligned to 4 bytes)
    int rowPadded = ((width * 3 + 3) / 4) * 4;
    unsigned char* raw = (unsigned char*)malloc(rowPadded * absHeight);
    if (!raw) { fclose(f); return 0; }

    // Read the raw pixel data
    for (int i = 0; i < absHeight; ++i) {
        if (fread(raw + i * rowPadded, 1, rowPadded, f) != (size_t)rowPadded) {
            free(raw);
            fclose(f);
            return 0;
        }
    }
    fclose(f);

    // Convert to tightly packed BGR buffer (remove padding)
    unsigned char* pixels = (unsigned char*)malloc(width * absHeight * 3);
    if (!pixels) { free(raw); return 0; }
    for (int row = 0; row < absHeight; ++row) {
        // Handle bottom-up vs top-down storage
        int srcRow = (height > 0) ? (absHeight - 1 - row) : row; 
        unsigned char* src = raw + srcRow * rowPadded;
        unsigned char* dst = pixels + row * width * 3;
        for (int x = 0; x < width; ++x) {
            // Copy B, G, R components
            dst[x * 3 + 0] = src[x * 3 + 0];
            dst[x * 3 + 1] = src[x * 3 + 1];
            dst[x * 3 + 2] = src[x * 3 + 2];
        }
    }
    free(raw);

    // Resample to 512x512 if needed (power of 2 is safer for compatibility)
    const int TARGET_SIZE = 512;
    unsigned char* uploadPixels = pixels;
    int uploadW = width;
    int uploadH = absHeight;
    unsigned char* resized = NULL;
    if (uploadW != TARGET_SIZE || uploadH != TARGET_SIZE) {
        resized = ResizeNearest(pixels, uploadW, uploadH, TARGET_SIZE, TARGET_SIZE);
        if (resized) {
            uploadPixels = resized;
            uploadW = TARGET_SIZE;
            uploadH = TARGET_SIZE;
            free(pixels);
        } else {
            printf("LoadBMP: resize failed, using original size %dx%d\n", uploadW, uploadH);
        }
    }

    // Create GL texture
    GLuint tex = 0;
    glGenTextures(1, &tex); // Generate 1 texture ID
    glBindTexture(GL_TEXTURE_2D, tex); // Bind it as the current 2D texture
    glPixelStorei(GL_UNPACK_ALIGNMENT, 1); // Set pixel storage mode
    
    // Build mipmaps (automatically generates smaller versions of the texture for distance rendering)
    if (gluBuild2DMipmaps(GL_TEXTURE_2D, GL_RGB, uploadW, uploadH, GL_BGR, GL_UNSIGNED_BYTE, uploadPixels) != 0) {
        printf("LoadBMP: gluBuild2DMipmaps failed for %s\n", path);
        glDeleteTextures(1, &tex);
        tex = 0;
    } else {
        // Set texture filtering parameters (Linear interpolation for smooth look)
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        // Set texture wrapping to repeat
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    }

    if (resized) free(resized);
    else free(pixels);

    return tex; // Return the generated texture ID
}

// Load a 24-bit BMP from disk, support padding, bottom-up rows, NO RESIZING (for cake texture to preserve colors).
// This version skips resizing to keep the original texture quality/aspect ratio.
static GLuint LoadBMPAndCreateGLTextureNoResize(const char* path) {
    FILE* f = fopen(path, "rb");
    if (!f) {
        printf("LoadBMP: failed to open %s\n", path);
        return 0;
    }

    unsigned char fileHeader[14];
    if (fread(fileHeader, 1, 14, f) != 14) { fclose(f); return 0; }
    if (fileHeader[0] != 'B' || fileHeader[1] != 'M') {
        printf("LoadBMP: %s is not a BMP\n", path);
        fclose(f);
        return 0;
    }
    unsigned int dataOffset = *(unsigned int*)&fileHeader[10];

    unsigned char infoHeader[40];
    if (fread(infoHeader, 1, 40, f) != 40) { fclose(f); return 0; }
    int width = *(int*)&infoHeader[4];
    int height = *(int*)&infoHeader[8];
    short planes = *(short*)&infoHeader[12];
    short bpp = *(short*)&infoHeader[14];

    if (bpp != 24) {
        printf("LoadBMP: %s is not 24-bit (bpp=%d) - attempting to continue\n", path, bpp);
    }

    if (width <= 0 || height == 0) {
        printf("LoadBMP: invalid dimensions %dx%d in %s\n", width, height, path);
        fclose(f);
        return 0;
    }

    int absHeight = (height > 0) ? height : -height;

    fseek(f, dataOffset, SEEK_SET);

    int rowPadded = ((width * 3 + 3) / 4) * 4;
    unsigned char* raw = (unsigned char*)malloc(rowPadded * absHeight);
    if (!raw) { fclose(f); return 0; }

    for (int i = 0; i < absHeight; ++i) {
        if (fread(raw + i * rowPadded, 1, rowPadded, f) != (size_t)rowPadded) {
            free(raw);
            fclose(f);
            return 0;
        }
    }
    fclose(f);

    // Convert to tightly packed BGR buffer
    unsigned char* pixels = (unsigned char*)malloc(width * absHeight * 3);
    if (!pixels) { free(raw); return 0; }
    for (int row = 0; row < absHeight; ++row) {
        int srcRow = (height > 0) ? (absHeight - 1 - row) : row;
        unsigned char* src = raw + srcRow * rowPadded;
        unsigned char* dst = pixels + row * width * 3;
        for (int x = 0; x < width; ++x) {
            dst[x * 3 + 0] = src[x * 3 + 0];
            dst[x * 3 + 1] = src[x * 3 + 1];
            dst[x * 3 + 2] = src[x * 3 + 2];
        }
    }
    free(raw);

    // NO RESIZING - use original dimensions to preserve colors
    GLuint tex = 0;
    glGenTextures(1, &tex);
    glBindTexture(GL_TEXTURE_2D, tex);
    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    
    if (gluBuild2DMipmaps(GL_TEXTURE_2D, GL_RGB, width, absHeight, GL_BGR, GL_UNSIGNED_BYTE, pixels) != 0) {
        printf("LoadBMP: gluBuild2DMipmaps failed for %s\n", path);
        glDeleteTextures(1, &tex);
        tex = 0;
    } else {
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
        printf("LoadBMP: Loaded %s as %dx%d (no resize)\n", path, width, absHeight);
    }

    free(pixels);
    return tex;
}

// --- End texture helpers ---

// Models - Global instances of 3D models
Model_3DS carModel;
Model_3DS cakeModel;
Model_3DS gummyModel;
Model_3DS iceCreamCartModel;
Model_3DS gumballModel;
Model_3DS candyCaneModel;
Model_3DS cakePopModel;

// Display Lists - Optimization to store OpenGL commands on GPU
GLuint cakeDisplayList = 0; 
GLuint gummyDisplayList = 0; 
GLuint cartDisplayList = 0; 
GLuint gumballDisplayList = 0; 
GLuint candyCaneDisplayList = 0; 
GLuint cakePopDisplayList = 0; 
GLuint popsicleTreeDisplayList = 0; 
GLuint skyDisplayList = 0; 
GLuint carDisplayList = 0; 

// Player (Car) Structure - Holds state of the player's vehicle
struct Player {
    float x, y, z;     // Position
    float speed;       // Current speed
    float rotY;        // Car's facing direction (Yaw)
    float wheelRot;    // Visual wheel rotation angle
    bool headlightsOn; // State of headlights
    bool taillightsOn; // State of taillights
} player;

// Camera Structure - Holds state of the camera
struct Camera {
    int mode; // 0=Third Person, 1=First Person, 2=Top Down, 3=Mouse Look
    float dist;   // Distance from player
    float height; // Height above player
    float yaw;    // Horizontal angle
    float pitch;  // Vertical angle
} cam;

// Game Constants - Tuning parameters
const float MAX_SPEED = 1.5f; 
const float ACCELERATION = 0.02f;
const float DECELERATION = 0.96f;
const float TURN_SPEED = 2.0f;
const float ROAD_LENGTH = 1000.0f;
const int GAME_DURATION = 420; // 7 minutes

// Input State - Tracks keyboard and mouse
bool keyState[256] = { false };
bool mouseCaptured = false;
int lastMouseX = 0, lastMouseY = 0;

// Game State - Tracks global game variables
float timeOfDay = 0.0f; // 0.0 to 1.0 (0=Noon, 0.5=Sunset, 1.0=Midnight)
bool isDay = true;
int timeRemaining = GAME_DURATION;
int lastTime = 0;
int score = 0; // Game score

// Race State - Tracks race progression
bool raceStarted = false;
int raceStartTime = 0;
int trafficLightState = 0; // 0=Red, 1=Yellow, 2=Green

// Sound State - Tracks which sounds are playing
bool isRevving = false;
bool isDriving = false;
bool playedLoseSound = false;
bool playedWinSound = false;

// Game Logic State - Win/Loss conditions
bool gameOver = false;
bool levelWon = false;
int level = 1;
const float FINISH_LINE_Z = -900.0f; // Z-coordinate of finish line

// Tree Structure - For environment generation
struct Tree {
    float x, z;
    float scale;
};
std::vector<Tree> trees;

// Power-up Structure (Cakes)
struct PowerUp {
    float x, z;
    float rot;
    bool active;
};
std::vector<PowerUp> cakes;

// Speed Boost Logic
float speedBoostEndTime = 0.0f;
const float SPEED_BOOST_DURATION = 5.0f;
const float SPEED_BOOST_MULTIPLIER = 1.8f;

// Shield Power-up Logic
bool shieldActive = false;
float shieldEndTime = 0.0f;
const float SHIELD_DURATION = 15.0f; // 15 seconds
float invincibilityEndTime = 0.0f; // Grace period after shield break

// Collectibles (Gummy Bears)
struct Collectible {
    float x, z;
    float bobbingOffset; // For animation
    bool active;
};
std::vector<Collectible> gummies;

// Candy Canes (Level 2 Collectibles)
std::vector<Collectible> candyCanes;

// Obstacles (Ice Cream Carts)
struct Obstacle {
    float x, z;
    float rot; // Rotation angle
    bool active;
};
std::vector<Obstacle> obstacles;

// Gumball Machine Obstacles (Level 2)
struct GumballMachine {
    float x, z;
    float rot;
    bool active;
};
std::vector<GumballMachine> gumballs;

// Camera Shake
float cameraShakeIntensity = 0.0f;
float cameraShakeDuration = 0.0f;

// Helper to draw text on screen (2D overlay)
void drawText(float x, float y, const char* text, void* font = GLUT_BITMAP_HELVETICA_18) {
    glDisable(GL_LIGHTING); // Disable lighting so text color is flat
    glDisable(GL_DEPTH_TEST); // Disable depth test so text draws on top of everything
    
    // Switch to projection matrix to set up 2D orthographic view
    glMatrixMode(GL_PROJECTION);
    glPushMatrix(); // Save current projection
    glLoadIdentity();
    gluOrtho2D(0, 1024, 0, 768); // Map coordinates to window pixels (0,0 bottom-left to 1024,768 top-right)
    
    // Switch to modelview matrix
    glMatrixMode(GL_MODELVIEW);
    glPushMatrix(); // Save current modelview
    glLoadIdentity();
    
    glColor3f(1.0f, 1.0f, 1.0f); // Set text color to white
    glRasterPos2f(x, y); // Set position for text drawing
    
    // Loop through string and draw each character
    while (*text) {
        glutBitmapCharacter(font, *text);
        text++;
    }
    
    // Restore matrices and states
    glPopMatrix();
    glMatrixMode(GL_PROJECTION);
    glPopMatrix();
    glMatrixMode(GL_MODELVIEW);
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_LIGHTING);
}

// Helper to draw a cylinder using GLU quadrics
void drawCylinder(float radius, float height, int slices) {
    GLUquadricObj *quadric = gluNewQuadric();
    gluQuadricDrawStyle(quadric, GLU_FILL); // Draw filled polygons
    gluCylinder(quadric, radius, radius, height, slices, 1); // Draw cylinder
    gluDeleteQuadric(quadric); // Clean up
}

// Environment Drawing Functions
void drawStreet() {
    // --- Main Road ---
    glPushMatrix();
    glTranslatef(0, 0.01, 0); // Slightly above 0 to avoid z-fighting with ground
    glScalef(30.0f, 1.0f, ROAD_LENGTH); // Scale to road dimensions

    if (roadTexture != 0) {
        glEnable(GL_TEXTURE_2D);
        glBindTexture(GL_TEXTURE_2D, roadTexture);
        glColor3f(1.0f, 1.0f, 1.0f); // White to modulate texture correctly
        
        // Calculate texture tiling
        float tilesU = 30.0f / 10.0f;
        float tilesV = ROAD_LENGTH / 50.0f;
        
        // Draw Quad for road
        glBegin(GL_QUADS);
        glNormal3f(0, 1, 0); // Normal pointing up
        glTexCoord2f(0.0f, 0.0f); glVertex3f(-1, 0, -1);
        glTexCoord2f(0.0f, tilesV); glVertex3f(-1, 0, 1);
        glTexCoord2f(tilesU, tilesV); glVertex3f(1, 0, 1);
        glTexCoord2f(tilesU, 0.0f); glVertex3f(1, 0, -1);
        glEnd();
        glDisable(GL_TEXTURE_2D);
    } else {
        // Fallback: plain asphalt color
        glColor3f(0.2f, 0.2f, 0.2f); // Dark Grey Asphalt
        glBegin(GL_QUADS);
        glNormal3f(0, 1, 0);
        glVertex3f(-1, 0, -1);
        glVertex3f(-1, 0, 1);
        glVertex3f(1, 0, 1);
        glVertex3f(1, 0, -1);
        glEnd();
    }

    glPopMatrix();

    // --- Start Line ---
    glPushMatrix();
    glColor3f(1.0f, 1.0f, 1.0f); // White Checkered Pattern Base
    glTranslatef(0, 0.02, 10.0f); // Position at start
    glScalef(28.0f, 1.0f, 4.0f);
    glBegin(GL_QUADS);
    glNormal3f(0, 1, 0);
    glVertex3f(-1, 0, -0.5);
    glVertex3f(-1, 0, 0.5);
    glVertex3f(1, 0, 0.5);
    glVertex3f(1, 0, -0.5);
    glEnd();
    glPopMatrix();

    // --- Lane Markers ---
    glColor3f(1.0f, 1.0f, 0.0f); // Yellow lines
    for (int i = -ROAD_LENGTH/2; i < ROAD_LENGTH/2; i += 20) {
        glPushMatrix();
        glTranslatef(0, 0.02, i); // Position along road
        glScalef(0.8f, 1.0f, 6.0f); // Thin strip
        glBegin(GL_QUADS);
        glNormal3f(0, 1, 0);
        glVertex3f(-1, 0, -1);
        glVertex3f(-1, 0, 1);
        glVertex3f(1, 0, 1);
        glVertex3f(1, 0, -1);
        glEnd();
        glPopMatrix();
    }

    // --- Finish Line ---
    if (level == 1) {
        // Level 1: Holographic Finish Gate
        glPushMatrix();
        glEnable(GL_BLEND); // Enable transparency
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        
        float time = glutGet(GLUT_ELAPSED_TIME) / 1000.0f;
        float bounce = 0.0f;
        if (levelWon) {
            bounce = sin(time * 5.0f) * 1.5f; // Bounce animation when won
        }
        
        glTranslatef(0, 1.0f + bounce, FINISH_LINE_Z); 
        
        glScalef(28.0f, 4.0f, 1.0f); // Standing up like a gate
        
        if (finishLineTexture != 0) {
            // Apply finish line texture
            glDisable(GL_LIGHTING);
            glEnable(GL_TEXTURE_2D);
            glBindTexture(GL_TEXTURE_2D, finishLineTexture);
            glColor3f(1.0f, 1.0f, 1.0f);
            
            glBegin(GL_QUADS);
            glNormal3f(0, 0, 1);
            glTexCoord2f(0.0f, 0.0f); glVertex3f(-1, -1, 0);
            glTexCoord2f(5.0f, 0.0f); glVertex3f(1, -1, 0);
            glTexCoord2f(5.0f, 1.0f); glVertex3f(1, 1, 0);
            glTexCoord2f(0.0f, 1.0f); glVertex3f(-1, 1, 0);
            glEnd();
            
            glDisable(GL_TEXTURE_2D);
            glEnable(GL_LIGHTING);
        } else {
            // Fallback: Hologram Color (Cyan with transparency)
            glColor4f(0.0f, 1.0f, 1.0f, 0.6f); 
            
            glBegin(GL_QUADS);
            glNormal3f(0, 0, 1);
            glVertex3f(-1, -1, 0);
            glVertex3f(1, -1, 0);
            glVertex3f(1, 1, 0);
            glVertex3f(-1, 1, 0);
            glEnd();
        }
        
        glDisable(GL_BLEND);
        glPopMatrix();
    } else if (level == 2) {
        // Level 2: Car Finish Line (Spinning Car)
        glPushMatrix();
        glTranslatef(0, 1.0f, FINISH_LINE_Z);
        
        // Rotate the car when level is won
        float time = glutGet(GLUT_ELAPSED_TIME) / 1000.0f;
        if (levelWon) {
            glRotatef(time * 100.0f, 0, 1, 0); // Spin the car
        }
        
        glRotatef(180, 0, 1, 0); // Face the player
        
        // Draw car model
        glPushMatrix();
        glRotatef(-90, 1, 0, 0);
        glScalef(1.2f, 1.2f, 1.2f);
        
        // Red car color or texture
        if (carTexture != 0) {
            glEnable(GL_TEXTURE_2D);
            glBindTexture(GL_TEXTURE_2D, carTexture);
            glColor3f(1.0f, 1.0f, 1.0f);

            // Automatic texture coordinate generation in object space
            glEnable(GL_TEXTURE_GEN_S);
            glEnable(GL_TEXTURE_GEN_T);
            glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
            glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
            // Map S to X and T to Z to get a reasonable projection
            GLfloat sPlane[] = { 0.5f, 0.0f, 0.0f, 0.0f }; // scale X
            GLfloat tPlane[] = { 0.0f, 0.0f, 0.5f, 0.0f }; // scale Z
            glTexGenfv(GL_S, GL_OBJECT_PLANE, sPlane);
            glTexGenfv(GL_T, GL_OBJECT_PLANE, tPlane);

            carModel.Draw();

            // Cleanup
            glDisable(GL_TEXTURE_GEN_S);
            glDisable(GL_TEXTURE_GEN_T);
            glDisable(GL_TEXTURE_2D);
        } else {
            glColor3f(1.0f, 0.3f, 0.3f);
            carModel.Draw();
        }
        glPopMatrix();
        
        glPopMatrix();
    }
}

// Draw the traffic light at the start
void drawTrafficLight() {
    glPushMatrix();
    glTranslatef(15.0f, 0, 10.0f); // Right side of start line
    
    // Pole
    glColor3f(0.2f, 0.2f, 0.2f);
    glPushMatrix();
    glScalef(0.5f, 10.0f, 0.5f);
    glRotatef(-90, 1, 0, 0);
    drawCylinder(1, 1, 10); 
    glPopMatrix();
    
    // Box
    glTranslatef(0, 10.0f, 0);
    glColor3f(0.1f, 0.1f, 0.1f);
    glScalef(2.0f, 6.0f, 2.0f);
    glutSolidCube(1.0);
    
    // Lights (Emissive)
    glDisable(GL_LIGHTING); // Make them glow regardless of environment light
    
    // Red Light
    if (trafficLightState == 0) glColor3f(1.0f, 0.0f, 0.0f); // Bright Red
    else glColor3f(0.3f, 0.0f, 0.0f); // Dim Red
    glPushMatrix();
    glTranslatef(0, 0.3f, 0.6f);
    glutSolidSphere(0.3, 10, 10);
    glPopMatrix();
    
    // Yellow Light
    if (trafficLightState == 1) glColor3f(1.0f, 1.0f, 0.0f); // Bright Yellow
    else glColor3f(0.3f, 0.3f, 0.0f); // Dim Yellow
    glPushMatrix();
    glTranslatef(0, 0.0f, 0.6f);
    glutSolidSphere(0.3, 10, 10);
    glPopMatrix();
    
    // Green Light
    if (trafficLightState == 2) glColor3f(0.0f, 1.0f, 0.0f); // Bright Green
    else glColor3f(0.0f, 0.3f, 0.0f); // Dim Green
    glPushMatrix();
    glTranslatef(0, -0.3f, 0.6f);
    glutSolidSphere(0.3, 10, 10);
    glPopMatrix();
    
    glEnable(GL_LIGHTING);
    glPopMatrix();
}

// Draw a Sakura Tree (Level 1) using primitives
void drawSakuraTree(float x, float z, float scale) {
    glPushMatrix();
    glTranslatef(x, 0, z);
    glScalef(scale * 1.5f, scale * 1.5f, scale * 1.5f); // Taller trees

    // Trunk
    glColor3f(0.4f, 0.26f, 0.13f); // Brown
    glPushMatrix();
    glScalef(0.5f, 4.0f, 0.5f);
    glRotatef(-90, 1, 0, 0);
    glutSolidCone(1, 1, 10, 10); // Base
    glPopMatrix();
    
    // Trunk cylinder manual approximation
    glPushMatrix();
    glScalef(0.3f, 3.0f, 0.3f);
    glTranslatef(0, 0.5, 0);
    glutSolidCube(1.0);
    glPopMatrix();

    // Leaves (Pink Cloud)
    glColor3f(1.0f, 0.6f, 0.8f); // Sakura Pink
    glPushMatrix();
    glTranslatef(0, 3.5f, 0);
    glutSolidSphere(2.0, 10, 10);
    glTranslatef(1.0f, 0.5f, 0.5f);
    glutSolidSphere(1.5, 10, 10);
    glTranslatef(-2.0f, -0.2f, -1.0f);
    glutSolidSphere(1.5, 10, 10);
    glPopMatrix();

    glPopMatrix();
}

// Draw a Popsicle Tree (Level 2) using primitives or display list
void drawPopsicleTree(float x, float z, float scale) {
    glPushMatrix();
    glTranslatef(x, 0, z);
    
    if (popsicleTreeDisplayList != 0) {
        float s = scale * 1.5f;
        glScalef(s, s, s);
        glCallList(popsicleTreeDisplayList); // Use optimized display list
    } else {
        // Fallback if display list creation failed
        glScalef(scale * 1.5f, scale * 1.5f, scale * 1.5f);

        // Stick (Tan/Wood color)
        glColor3f(0.8f, 0.6f, 0.4f);
        glPushMatrix();
        glScalef(0.3f, 2.0f, 0.1f);
        glTranslatef(0, 0.5, 0);
        glutSolidCube(1.0);
        glPopMatrix();

        // Popsicle Body (Icy Blue/White)
        glColor3f(0.6f, 0.8f, 1.0f); // Icy Blue
        glPushMatrix();
        glTranslatef(0, 3.0f, 0);
        glScalef(1.0f, 2.5f, 0.3f);
        
        // Main body
        glutSolidCube(1.0);
        
        // Rounded top
        glTranslatef(0, 0.5f, 0);
        glScalef(1.0f, 0.5f, 1.0f);
        glutSolidSphere(0.6, 10, 10);
        glPopMatrix();
    }

    glPopMatrix();
}

// Main Environment Drawing Function
void drawEnvironment() {
    // --- Sky ---
    if (skyTexture != 0) {
        glPushMatrix();
        glDisable(GL_LIGHTING); // Sky is self-illuminated
        glDisable(GL_DEPTH_TEST); // Draw background first
        glEnable(GL_TEXTURE_2D);
        glBindTexture(GL_TEXTURE_2D, skyTexture);
        glColor3f(1.0f, 1.0f, 1.0f);
        
        if (skyDisplayList != 0) {
            glCallList(skyDisplayList);
        } else {
            GLUquadricObj *quadric = gluNewQuadric();
            gluQuadricTexture(quadric, GL_TRUE);
            gluQuadricNormals(quadric, GLU_SMOOTH);
            
            // Rotate to align texture properly
            glRotatef(-90, 1, 0, 0); 
            
            gluSphere(quadric, 1500.0, 32, 32); // Large sphere surrounding the world
            
            gluDeleteQuadric(quadric);
        }
        
        glDisable(GL_TEXTURE_2D);
        glEnable(GL_DEPTH_TEST);
        glEnable(GL_LIGHTING);
        glPopMatrix();
    }

    // --- Ground ---
    glPushMatrix();
    if (level == 2) {
        // Level 2: Snow Ground
        if (snowTexture != 0) {
            glEnable(GL_TEXTURE_2D);
            glBindTexture(GL_TEXTURE_2D, snowTexture);
            glColor3f(1.0f, 1.0f, 1.0f);
            // Tile the texture across the large ground area
            float tiles = ROAD_LENGTH / 50.0f; // tweak tiling density here
            glBegin(GL_QUADS);
            glNormal3f(0, 1, 0);
            glTexCoord2f(0.0f, 0.0f); glVertex3f(-ROAD_LENGTH, 0, -ROAD_LENGTH);
            glTexCoord2f(tiles, 0.0f); glVertex3f(-ROAD_LENGTH, 0, ROAD_LENGTH);
            glTexCoord2f(tiles, tiles); glVertex3f(ROAD_LENGTH, 0, ROAD_LENGTH);
            glTexCoord2f(0.0f, tiles); glVertex3f(ROAD_LENGTH, 0, -ROAD_LENGTH);
            glEnd();
            glDisable(GL_TEXTURE_2D);
        } else {
            glColor3f(0.8f, 0.9f, 1.0f); // Icy White/Blue Ground
            glBegin(GL_QUADS);
            glNormal3f(0, 1, 0);
            glVertex3f(-ROAD_LENGTH, 0, -ROAD_LENGTH);
            glVertex3f(-ROAD_LENGTH, 0, ROAD_LENGTH);
            glVertex3f(ROAD_LENGTH, 0, ROAD_LENGTH);
            glVertex3f(ROAD_LENGTH, 0, -ROAD_LENGTH);
            glEnd();
        }
    } else {
        // Level 1: Grass Ground
        if (grassTexture != 0) {
            glEnable(GL_TEXTURE_2D);
            glBindTexture(GL_TEXTURE_2D, grassTexture);
            glColor3f(1.0f, 1.0f, 1.0f);
            // Tile the texture across the large ground area
            float tiles = ROAD_LENGTH / 50.0f; // tweak tiling density here
            glBegin(GL_QUADS);
            glNormal3f(0, 1, 0);
            glTexCoord2f(0.0f, 0.0f); glVertex3f(-ROAD_LENGTH, 0, -ROAD_LENGTH);
            glTexCoord2f(tiles, 0.0f); glVertex3f(-ROAD_LENGTH, 0, ROAD_LENGTH);
            glTexCoord2f(tiles, tiles); glVertex3f(ROAD_LENGTH, 0, ROAD_LENGTH);
            glTexCoord2f(0.0f, tiles); glVertex3f(ROAD_LENGTH, 0, -ROAD_LENGTH);
            glEnd();
            glDisable(GL_TEXTURE_2D);
        } else {
            glColor3f(0.0f, 0.5f, 0.2f); // Green Grass
            glBegin(GL_QUADS);
            glNormal3f(0, 1, 0);
            glVertex3f(-ROAD_LENGTH, 0, -ROAD_LENGTH);
            glVertex3f(-ROAD_LENGTH, 0, ROAD_LENGTH);
            glVertex3f(ROAD_LENGTH, 0, ROAD_LENGTH);
            glVertex3f(ROAD_LENGTH, 0, -ROAD_LENGTH);
            glEnd();
        }
    }
    glPopMatrix();

    drawStreet();
    drawTrafficLight();

    // --- Draw Randomized Trees ---
    for (const auto& tree : trees) {
        // Level 2 optimization: Only draw trees within visible distance
        if (level == 2) {
            float dx = player.x - tree.x;
            float dz = player.z - tree.z;
            float dist2 = dx*dx + dz*dz;
            // Only render trees within ~120 units (squared distance check for performance)
            if (dist2 < (120.0f * 120.0f)) {
                drawPopsicleTree(tree.x, tree.z, tree.scale);
            }
        } else {
            drawSakuraTree(tree.x, tree.z, tree.scale);
        }
    }
    
    // --- Draw Active Cakes (Level 1 Power-ups) ---
    if (level == 1) {
        float time = glutGet(GLUT_ELAPSED_TIME) / 1000.0f;
        for (const auto& cake : cakes) {
            if (cake.active) {
                // Only render cakes within reasonable distance for performance
                float dz = player.z - cake.z;
                if (fabs(dz) < 200.0f) { // Culling distance
                    glPushMatrix();
                    glTranslatef(cake.x, 0.5f, cake.z); // On the road
                    glRotatef(cake.rot, 0, 1, 0); // Rotate around Y axis
                    glScalef(0.08f, 0.08f, 0.08f); // Smaller size
                    
                    // Apply cake texture if loaded
                    if (cakeTexture != 0) {
                        glEnable(GL_TEXTURE_2D);
                        glBindTexture(GL_TEXTURE_2D, cakeTexture);
                        glColor3f(1.0f, 1.0f, 1.0f); // White to show texture colors properly
                        
                        // MUST call cakeModel.Draw() directly (not display list) to get texture coords!
                        cakeModel.Draw();
                        
                        glDisable(GL_TEXTURE_2D);
                    } else {
                        // Fallback: Colorful RGB cycling effect
                        float r = 0.5f + 0.5f * sin(time * 2.0f);
                        float g = 0.5f + 0.5f * sin(time * 2.0f + 2.0f);
                        float b = 0.5f + 0.5f * sin(time * 2.0f + 4.0f);
                        glColor3f(r, g, b);
                        
                        // Use display list for better performance (no texture)
                        if (cakeDisplayList != 0) {
                            glCallList(cakeDisplayList);
                        } else {
                            cakeModel.Draw();
                        }
                    }
                    
                    glPopMatrix();
                }
            }
        }
    }

    // --- Draw Cake Pops (Level 2 Power-ups) ---
    if (level == 2) {
        float time = glutGet(GLUT_ELAPSED_TIME) / 1000.0f;
        for (const auto& cake : cakes) {
            if (cake.active) {
                float dz = player.z - cake.z;
                if (fabs(dz) < 200.0f) {
                    glPushMatrix();
                    glTranslatef(cake.x, 3.0f, cake.z);
                    glRotatef(cake.rot, 0, 1, 0); // Rotate around Y axis
                    glScalef(8.0f, 8.0f, 8.0f); // Much larger scale for visibility
                    
                    if (cakePopTexture != 0) {
                        glEnable(GL_TEXTURE_2D);
                        glBindTexture(GL_TEXTURE_2D, cakePopTexture);
                        glColor3f(1.0f, 1.0f, 1.0f);
                        
                        if (cakePopDisplayList != 0) {
                            glCallList(cakePopDisplayList);
                        } else {
                            cakePopModel.Draw();
                        }
                        
                        glDisable(GL_TEXTURE_2D);
                    } else {
                        // Fallback: Colorful cake pop
                        float r = 0.5f + 0.5f * sin(time * 2.0f);
                        float g = 0.5f + 0.5f * sin(time * 2.0f + 2.0f);
                        float b = 0.5f + 0.5f * sin(time * 2.0f + 4.0f);
                        glColor3f(r, g, b);
                        
                        if (cakePopDisplayList != 0) {
                            glCallList(cakePopDisplayList);
                        } else {
                            cakePopModel.Draw();
                        }
                    }
                    glPopMatrix();
                }
            }
        }
    }
    
    // --- Draw Active Gummy Bears (Level 1 Collectibles) ---
    if (level == 1) {
        for (const auto& gummy : gummies) {
            if (gummy.active) {
                float dz = player.z - gummy.z;
                if (fabs(dz) < 200.0f) { // Culling distance
                    glPushMatrix();
                    glTranslatef(gummy.x, 1.0f + gummy.bobbingOffset, gummy.z); // Hovering
                    glScalef(0.5f, 0.5f, 0.5f); // Appropriate size
                    
                    if (gummyTexture != 0) {
                        // Apply gummy texture with spherical mapping
                        glEnable(GL_TEXTURE_2D);
                        glBindTexture(GL_TEXTURE_2D, gummyTexture);
                        glColor3f(1.0f, 1.0f, 1.0f);
                        
                        // Use spherical texture coordinate generation
                        glEnable(GL_TEXTURE_GEN_S);
                        glEnable(GL_TEXTURE_GEN_T);
                        glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP);
                        glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP);
                        
                        if (gummyDisplayList != 0) {
                            glCallList(gummyDisplayList);
                        } else {
                            gummyModel.Draw();
                        }
                        
                        glDisable(GL_TEXTURE_GEN_S);
                        glDisable(GL_TEXTURE_GEN_T);
                        glDisable(GL_TEXTURE_2D);
                    } else {
                        // Fallback: green color
                        glColor3f(0.2f, 0.9f, 0.2f);
                        
                        if (gummyDisplayList != 0) {
                            glCallList(gummyDisplayList);
                        } else {
                            gummyModel.Draw();
                        }
                    }
                    glPopMatrix();
                }
            }
        }
    }

    // --- Draw Candy Canes (Level 2 Collectibles) ---
    if (level == 2) {
        for (const auto& candy : candyCanes) {
            if (candy.active) {
                float dz = player.z - candy.z;
                if (fabs(dz) < 120.0f) { // Tighter culling for Level 2
                    glPushMatrix();
                    glTranslatef(candy.x, 1.0f + candy.bobbingOffset, candy.z); // Hovering
                    glRotatef(90, 0, 0, 1);
                    glScalef(0.5f, 0.5f, 0.5f);
                    
                    if (candyCaneTexture != 0) {
                        // Apply candy cane texture with spherical mapping
                        glEnable(GL_TEXTURE_2D);
                        glBindTexture(GL_TEXTURE_2D, candyCaneTexture);
                        glColor3f(1.0f, 1.0f, 1.0f);
                        
                        glEnable(GL_TEXTURE_GEN_S);
                        glEnable(GL_TEXTURE_GEN_T);
                        glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP);
                        glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP);
                        
                        if (candyCaneDisplayList != 0) { glCallList(candyCaneDisplayList); } else { candyCaneModel.Draw(); }
                        
                        glDisable(GL_TEXTURE_GEN_S);
                        glDisable(GL_TEXTURE_GEN_T);
                        glDisable(GL_TEXTURE_2D);
                    } else {
                        // Fallback: red color
                        glColor3f(1.0f, 0.2f, 0.2f);
                        if (candyCaneDisplayList != 0) { glCallList(candyCaneDisplayList); } else { candyCaneModel.Draw(); }
                    }
                    
                    glPopMatrix();
                }
            }
        }
    }
    
    // --- Draw Ice Cream Cart Obstacles ---
    for (const auto& cart : obstacles) {
        if (cart.active) {
            float dz = player.z - cart.z;
            if (fabs(dz) < 200.0f) { // Culling distance
                glPushMatrix();
                glTranslatef(cart.x, 0.0f, cart.z);
                
                // Apply animation rotation
                glRotatef(cart.rot, 0, 1, 0);
                
                // Fix orientation: Rotate -90 around X-axis to stand it up (Z-up to Y-up)
                // Then rotate 180 around Y to face the player if needed, or 90 if it's sideways
                glRotatef(-90, 1, 0, 0); 
                glRotatef(180, 0, 0, 1); // Adjust facing direction (around new Z-axis which was Y)
                
                glScalef(0.05f, 0.05f, 0.05f); // Scaled down tremendously
                
                if (level == 1 && vendingCartTexture != 0) {
                    // Textured vending cart (STL has no UVs -> use automatic texgen)
                    glEnable(GL_TEXTURE_2D);
                    glBindTexture(GL_TEXTURE_2D, vendingCartTexture);
                    glColor3f(1.0f, 1.0f, 1.0f);

                    glEnable(GL_TEXTURE_GEN_S);
                    glEnable(GL_TEXTURE_GEN_T);
                    glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
                    glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
                    // Project along X/Z
                    GLfloat sPlaneCart[] = { 0.2f, 0.0f, 0.0f, 0.0f }; // tweak tiling
                    GLfloat tPlaneCart[] = { 0.0f, 0.0f, 0.2f, 0.0f };
                    glTexGenfv(GL_S, GL_OBJECT_PLANE, sPlaneCart);
                    glTexGenfv(GL_T, GL_OBJECT_PLANE, tPlaneCart);

                    if (cartDisplayList != 0) {
                        glCallList(cartDisplayList);
                    } else {
                        iceCreamCartModel.Draw();
                    }

                    glDisable(GL_TEXTURE_GEN_S);
                    glDisable(GL_TEXTURE_GEN_T);
                    glDisable(GL_TEXTURE_2D);
                } else {
                    // Fallback: color only (pink)
                    glDisable(GL_LIGHTING); // Disable lighting to force color to show
                    glDisable(GL_TEXTURE_2D); // Ensure no texture is affecting color
                    glColor3f(1.0f, 0.0f, 1.0f); // Pink

                    if (cartDisplayList != 0) {
                        glCallList(cartDisplayList);
                    } else {
                        iceCreamCartModel.Draw();
                    }

                    glEnable(GL_TEXTURE_2D); // Re-enable textures for other objects
                    glEnable(GL_LIGHTING); // Re-enable lighting
                }

                glPopMatrix();
            }
        }
    }

    // --- Draw Gumball Machines (Level 2 Obstacles) ---
    if (level == 2) {
        for (const auto& machine : gumballs) {
            if (machine.active) {
                float dz = player.z - machine.z;
                if (fabs(dz) < 120.0f) { // Tighter culling for Level 2
                    glPushMatrix();
                    glTranslatef(machine.x, 3.0f, machine.z); // Raised position
                    
                    // Rotate animation
                    glRotatef(machine.rot, 0, 1, 0);
                    glRotatef(90, 0, 1, 0);
                    
                    // Scale and orient
                    glScalef(0.05f, 0.05f, 0.05f); 
                  
                    // Apply gumball machine texture if loaded
                    if (gumballTexture != 0) {
                        glEnable(GL_TEXTURE_2D);
                        glBindTexture(GL_TEXTURE_2D, gumballTexture);
                        glColor3f(1.0f, 1.0f, 1.0f);

                        // Automatic texture coordinate generation for STL model
                        glEnable(GL_TEXTURE_GEN_S);
                        glEnable(GL_TEXTURE_GEN_T);
                        glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
                        glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
                        // Project texture coordinates
                        GLfloat sPlaneGumball[] = { 0.15f, 0.0f, 0.0f, 0.0f };
                        GLfloat tPlaneGumball[] = { 0.0f, 0.15f, 0.0f, 0.0f };
                        glTexGenfv(GL_S, GL_OBJECT_PLANE, sPlaneGumball);
                        glTexGenfv(GL_T, GL_OBJECT_PLANE, tPlaneGumball);

                        if (gumballDisplayList != 0) {
                            glCallList(gumballDisplayList);
                        } else {
                            gumballModel.Draw();
                        }

                        glDisable(GL_TEXTURE_GEN_S);
                        glDisable(GL_TEXTURE_GEN_T);
                        glDisable(GL_TEXTURE_2D);
                    } else {
                        // Fallback: Red color to ensure visibility
                        glColor3f(1.0f, 0.0f, 0.0f);
                        if (gumballDisplayList != 0) {
                            glCallList(gumballDisplayList);
                        } else {
                            gumballModel.Draw();
                        }
                    }
                    glPopMatrix();
                }
            }
        }
    }
}

// Helper to draw a tire
void drawTire(float x, float y, float z) {
    glPushMatrix();
    glTranslatef(x, y, z);
    glColor3f(0.1f, 0.1f, 0.1f); // Black Tire
    glutSolidTorus(0.2, 0.5, 10, 20); // Inner radius 0.2, Outer 0.5
    
    // Rim
    glColor3f(0.8f, 0.8f, 0.8f); // Silver Rim
    glScalef(0.5f, 0.5f, 0.5f);
    glutSolidTorus(0.1, 0.6, 5, 10);
    glPopMatrix();
}

// Initialization Routine
void Init() {
    srand(time(0)); // Seed random number generator

    // Initialize Player State
    player.x = 0;
    player.y = 1.0f; 
    player.z = 25.0f; 
    player.speed = 0;
    player.rotY = 180; // Reversed direction (facing away from camera initially)
    player.wheelRot = 0;
    player.headlightsOn = false;
    player.taillightsOn = false;

    // Initialize Camera State
    cam.mode = 0; // Third Person
    cam.dist = 25.0f; 
    cam.height = 10.0f;
    cam.yaw = 180.0f; 
    cam.pitch = 0.0f;

    // Generate Random Trees for the environment
    for (int i = 0; i < 200; i++) {
        Tree t;
        float side = (rand() % 2 == 0) ? 1.0f : -1.0f; // Left or Right side
        float distFromRoad = 35.0f + (rand() % 50); // Distance from road center
        t.x = side * distFromRoad;
        t.z = (rand() % (int)ROAD_LENGTH) - (ROAD_LENGTH/2); // Random Z along road
        t.scale = 0.8f + ((rand() % 50) / 100.0f); // Random scale variation
        trees.push_back(t);
    }

    // --- Load 3D Models ---
    printf("Loading car model...\n");
    carModel.LoadSTL("models/car_model_toon_animation.stl");
    printf("Car model loaded!\n");
    
    printf("Loading cake model...\n");
    cakeModel.Load("models/Cake.obj");
    printf("Cake model loaded!\n");
    
    // Create display list for cake (cache geometry for performance)
    printf("Creating cake display list for optimization...\n");
    cakeDisplayList = glGenLists(1);
    if (cakeDisplayList != 0) {
        glNewList(cakeDisplayList, GL_COMPILE);
        cakeModel.Draw();
        glEndList();
        printf("Cake display list created successfully!\n");
    }
    
    printf("Loading gummy model...\n");
    gummyModel.LoadSTL("models/gummybear.stl"); // Using STL to check triangle count
    printf("Gummy model loaded!\n");
    
    // Create display list for gummy
    printf("Creating gummy display list for optimization...\n");
    gummyDisplayList = glGenLists(1);
    if (gummyDisplayList != 0) {
        glNewList(gummyDisplayList, GL_COMPILE);
        gummyModel.Draw();
        glEndList();
        printf("Gummy display list created successfully!\n");
    }
    
    printf("Loading ice cream cart model...\n");
    iceCreamCartModel.LoadSTL("models/13924_Ice_Cream_vending_Cart_v2_l2.stl");
    printf("Ice cream cart model loaded!\n");
    
    // Create display list for cart
    printf("Creating cart display list for optimization...\n");
    cartDisplayList = glGenLists(1);
    if (cartDisplayList != 0) {
        glNewList(cartDisplayList, GL_COMPILE);
        iceCreamCartModel.Draw();
        glEndList();
        printf("Cart display list created successfully!\n");
    }
    
    // Initialize Cakes along the road (reduced to 10 for performance)
    for (int i = 0; i < 10; i++) {
        PowerUp cake;
        cake.x = 0; // Center of road
        cake.z = -100.0f - (i * 60.0f); // Spaced 60 units apart
        cake.rot = 0;
        cake.active = true;
        cakes.push_back(cake);
    }

    printf("Loading cake pop model...\n");
    cakePopModel.Load("models/53aabfc6404c_Cake_pop__3d_asset_.obj");
    printf("Cake pop model loaded!\n");

    // Create display list for cake pop
    cakePopDisplayList = glGenLists(1);
    if (cakePopDisplayList != 0) {
        glNewList(cakePopDisplayList, GL_COMPILE);
        cakePopModel.Draw();
        glEndList();
    }

    // Create display list for popsicle tree (Level 2 tree)
    popsicleTreeDisplayList = glGenLists(1);
    if (popsicleTreeDisplayList != 0) {
        glNewList(popsicleTreeDisplayList, GL_COMPILE);
        
        // Stick (Tan/Wood color)
        glColor3f(0.8f, 0.6f, 0.4f);
        glPushMatrix();
        glScalef(0.3f, 2.0f, 0.1f);
        glTranslatef(0, 0.5, 0);
        glutSolidCube(1.0);
        glPopMatrix();

        // Popsicle Body (Icy Blue/White)
        glColor3f(0.6f, 0.8f, 1.0f); // Icy Blue
        glPushMatrix();
        glTranslatef(0, 3.0f, 0);
        glScalef(1.0f, 2.5f, 0.3f);
        
        // Main body
        glutSolidCube(1.0);
        
        // Rounded top
        glTranslatef(0, 0.5f, 0);
        glScalef(1.0f, 0.5f, 1.0f);
        glutSolidSphere(0.6, 10, 10);
        glPopMatrix();
        
        glEndList();
    }

    // Create display list for sky sphere
    skyDisplayList = glGenLists(1);
    if (skyDisplayList != 0) {
        glNewList(skyDisplayList, GL_COMPILE);
        GLUquadricObj *quadric = gluNewQuadric();
        gluQuadricTexture(quadric, GL_TRUE);
        gluQuadricNormals(quadric, GLU_SMOOTH);
        glRotatef(-90, 1, 0, 0); 
        gluSphere(quadric, 1500.0, 32, 32);
        gluDeleteQuadric(quadric);
        glEndList();
    }

    // Create display list for car
    carDisplayList = glGenLists(1);
    if (carDisplayList != 0) {
        glNewList(carDisplayList, GL_COMPILE);
        carModel.Draw();
        glEndList();
    }
    
    // Initialize Gummy Bears along the road
    for (int i = 0; i < 20; i++) {
        Collectible gummy;
        // Alternate between left and right sides of the road
        float side = (i % 2 == 0) ? -5.0f : 5.0f;
        gummy.x = side;
        gummy.z = -80.0f - (i * 40.0f); // Spaced 40 units apart
        gummy.bobbingOffset = 0;
        gummy.active = true;
        gummies.push_back(gummy);
    }

    printf("Loading candy cane model...\n");
    candyCaneModel.LoadSTL("models/candyCane.stl");
    printf("Candy cane model loaded!\n");

    // Create display list for candy cane
    candyCaneDisplayList = glGenLists(1);
    if (candyCaneDisplayList != 0) {
        glNewList(candyCaneDisplayList, GL_COMPILE);
        candyCaneModel.Draw();
        glEndList();
    }

    // Initialize Candy Canes for Level 2
    for (int i = 0; i < 20; i++) {
        Collectible candy;
        float side = (i % 2 == 0) ? -5.0f : 5.0f;
        candy.x = side;
        candy.z = -80.0f - (i * 40.0f);
        candy.bobbingOffset = 0;
        candy.active = true;
        candyCanes.push_back(candy);
    }
    
    // Initialize Ice Cream Cart Obstacles
    for (int i = 0; i < 8; i++) {
        Obstacle cart;
        // Alternate sides for variety
        float side = (rand() % 2 == 0) ? -8.0f : 8.0f;
        cart.x = side;
        cart.z = -150.0f - (i * 80.0f); // Spaced further apart
        cart.rot = 0.0f;
        cart.active = true;
        obstacles.push_back(cart);
    }

    printf("Loading gumball machine model...\n");
    gumballModel.LoadSTL("models/gumball machine/Candy Machine N040717.stl");
    printf("Gumball machine model loaded!\n");

    // Create display list for gumball machine
    gumballDisplayList = glGenLists(1);
    if (gumballDisplayList != 0) {
        glNewList(gumballDisplayList, GL_COMPILE);
        gumballModel.Draw();
        glEndList();
    }

    // Initialize Gumball Machines for Level 2 (OBJ file is lighter - 7MB vs 12MB STL)
    for (int i = 0; i < 5; i++) { // Increased from 3 to 5 since OBJ is more optimized
        GumballMachine machine;
        float side = (rand() % 2 == 0) ? -8.0f : 8.0f;
        machine.x = side;
        machine.z = -200.0f - (i * 150.0f); // Spaced far apart
        machine.rot = 0.0f;
        machine.active = true;
        gumballs.push_back(machine);
    }

    // --- Initialize Audio (MCI) ---
    mciSendStringA("open \"sounds/car-engine-revving-94831.mp3\" type mpegvideo alias revving", NULL, 0, NULL);
    mciSendStringA("open \"sounds/car-sound-effect-126709.mp3\" type mpegvideo alias engine", NULL, 0, NULL);
    mciSendStringA("open \"sounds/consuming_cake_yummers.wav\" type waveaudio alias eat_cake", NULL, 0, NULL);
    mciSendStringA("open \"sounds/gummy_collect.mp3\" type mpegvideo alias collect_gummy", NULL, 0, NULL);
    mciSendStringA("open \"sounds/sound-effect-car-crash-394903.mp3\" type mpegvideo alias crash", NULL, 0, NULL);
    mciSendStringA("open \"sounds/losing-horn-313723.mp3\" type mpegvideo alias lose", NULL, 0, NULL);
    mciSendStringA("open \"sounds/victorymale-version-230553.mp3\" type mpegvideo alias win", NULL, 0, NULL);
    mciSendStringA("open \"sounds/shield-guard-6963.mp3\" type mpegvideo alias shield", NULL, 0, NULL);

    // --- Initialize Lighting ---
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0); // Sun
    glEnable(GL_LIGHT1); // Headlight Left
    glEnable(GL_LIGHT2); // Headlight Right
    glEnable(GL_LIGHT3); // Taillight Left
    glEnable(GL_LIGHT4); // Taillight Right
    
    glEnable(GL_COLOR_MATERIAL);
    glColorMaterial(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);
    
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_NORMALIZE);
    
    raceStartTime = glutGet(GLUT_ELAPSED_TIME);

    // --- Load Textures ---
    // Load grass texture for level 1
    grassTexture = LoadBMPAndCreateGLTexture("textures/grass.bmp");
    // Load road texture for both levels
    roadTexture = LoadBMPAndCreateGLTexture("textures/road.bmp");
    // Load cake texture for level 1 cake models (NO RESIZE to preserve colors!)
    cakeTexture = LoadBMPAndCreateGLTextureNoResize("textures/cake.bmp");
    // Load red car texture - check if file has .bmp extension
    carTexture = LoadBMPAndCreateGLTexture("textures/red_car_texture.bmp");
    if (carTexture == 0) {
        printf("TEXTURE LOADING FAILED! Check if file exists at textures/red_car_texture.bmp\n");
    } else {
        printf("Car texture loaded successfully! Texture ID: %u\n", carTexture);
    }

    // Load blue car texture for level 2
    blueCarTexture = LoadBMPAndCreateGLTexture("textures/blue_Car.bmp");
    if (blueCarTexture == 0) {
        printf("Blue car texture load failed: textures/blue_Car.bmp\n");
    } else {
        printf("Blue car texture loaded successfully! Texture ID: %u\n", blueCarTexture);
    }

    // Load vending cart texture for level 1 ice cream carts
    vendingCartTexture = LoadBMPAndCreateGLTexture("textures/vending_Cart.bmp");
    if (vendingCartTexture == 0) {
        printf("Vending cart texture load failed: textures/vending_Cart.bmp\n");
    } else {
        printf("Vending cart texture loaded. Texture ID: %u\n", vendingCartTexture);
    }
    // Load snow texture for level 2
    snowTexture = LoadBMPAndCreateGLTexture("textures/snow.bmp");
    if (snowTexture == 0) {
        printf("Snow texture load failed: textures/snow.bmp\n");
    } else {
        printf("Snow texture loaded. Texture ID: %u\n", snowTexture);
    }
    // Load gumball machine texture for level 2
    gumballTexture = LoadBMPAndCreateGLTexture("textures/gumball_machine.bmp");
    if (gumballTexture == 0) {
        printf("Gumball machine texture load failed: textures/gumball_machine.bmp\n");
    } else {
        printf("Gumball machine texture loaded. Texture ID: %u\n", gumballTexture);
    }

    // Load cake pop texture for level 2
    cakePopTexture = LoadBMPAndCreateGLTexture("textures/cake_pops.bmp");
    if (cakePopTexture == 0) {
        printf("Cake pop texture load failed: textures/cake_pops.bmp\n");
    } else {
        printf("Cake pop texture loaded. Texture ID: %u\n", cakePopTexture);
    }

    // Load sky texture
    skyTexture = LoadBMPAndCreateGLTextureNoResize("textures/clouds-sky-vertical-shot.bmp");
    if (skyTexture == 0) {
        printf("Sky texture load failed: textures/clouds-sky-vertical-shot.bmp\n");
    } else {
        printf("Sky texture loaded. Texture ID: %u\n", skyTexture);
    }

    // Load finish line texture
    finishLineTexture = LoadBMPAndCreateGLTexture("textures/finish_line_texture.bmp");
    if (finishLineTexture == 0) {
        printf("Finish line texture load failed: textures/finish_line_texture.bmp\n");
    } else {
        printf("Finish line texture loaded. Texture ID: %u\n", finishLineTexture);
    }

    // Load gummy texture
    gummyTexture = LoadBMPAndCreateGLTexture("textures/gummy_bear.bmp");
    if (gummyTexture == 0) {
        printf("Gummy texture load failed: textures/gummy_bear.bmp\n");
    } else {
        printf("Gummy texture loaded. Texture ID: %u\n", gummyTexture);
    }

    // Load candy cane texture
    candyCaneTexture = LoadBMPAndCreateGLTexture("textures/candy_cane_texture.bmp");
    if (candyCaneTexture == 0) {
        printf("Candy cane texture load failed: textures/candy_cane_texture.bmp\n");
    } else {
        printf("Candy cane texture loaded. Texture ID: %u\n", candyCaneTexture);
    }
}

// Update lighting based on time of day and car state
void updateLighting() {
    // Cycle time of day
    timeOfDay += 0.0005f; 
    if (timeOfDay > 2.0f) timeOfDay = 0.0f; 

    // Calculate ambient intensity based on time
    float intensity;
    if (timeOfDay <= 1.0f) {
        intensity = 1.0f - (timeOfDay * 0.9f); // Day to Dusk
    } else {
        intensity = 0.0f + ((timeOfDay - 1.0f) * 0.9f); // Night to Dawn
    }

    // Sun Position (Orbiting around Z axis)
    GLfloat lightPos[] = { 
        sin(timeOfDay * PI) * 100.0f, 
        cos(timeOfDay * PI) * 100.0f, 
        50.0f, 
        0.0f // Directional light (w=0)
    };
    
    // Sun Color (White -> Orange -> Dark)
    GLfloat lightColor[] = { intensity, intensity * 0.9f, intensity * 0.8f + 0.1f, 1.0f };
    
    glLightfv(GL_LIGHT0, GL_POSITION, lightPos);
    glLightfv(GL_LIGHT0, GL_AMBIENT, lightColor);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, lightColor);

    // Sky color matches light intensity
    glClearColor(lightColor[0] * 0.5f, lightColor[1] * 0.5f, lightColor[2] * 0.8f, 1.0f);

    // Car Headlights Logic
    float rad = player.rotY * PI / 180.0f;
    float dirX = sin(rad);
    float dirZ = cos(rad);

    if (player.headlightsOn) {
        GLfloat headLightColor[] = { 0.9f, 0.9f, 0.7f, 1.0f }; // Warm white
        
        // Headlights positions - Pointing down slightly to hit ground
        GLfloat hlPos1[] = { player.x + dirX * 2.5f - dirZ * 0.8f, player.y + 1.0f, player.z + dirZ * 2.5f + dirX * 0.8f, 1.0f };
        GLfloat hlPos2[] = { player.x + dirX * 2.5f + dirZ * 0.8f, player.y + 1.0f, player.z + dirZ * 2.5f - dirX * 0.8f, 1.0f };
        GLfloat hlDir[] = { dirX, -0.4f, dirZ }; 
        
        // Setup Spotlights
        glLightfv(GL_LIGHT1, GL_POSITION, hlPos1);
        glLightfv(GL_LIGHT1, GL_SPOT_DIRECTION, hlDir);
        glLightfv(GL_LIGHT1, GL_DIFFUSE, headLightColor);
        glLightf(GL_LIGHT1, GL_SPOT_CUTOFF, 50.0f); 
        glLightf(GL_LIGHT1, GL_SPOT_EXPONENT, 1.0f); 
        glEnable(GL_LIGHT1);
        
        glLightfv(GL_LIGHT2, GL_POSITION, hlPos2);
        glLightfv(GL_LIGHT2, GL_SPOT_DIRECTION, hlDir);
        glLightfv(GL_LIGHT2, GL_DIFFUSE, headLightColor);
        glLightf(GL_LIGHT2, GL_SPOT_CUTOFF, 50.0f);
        glLightf(GL_LIGHT2, GL_SPOT_EXPONENT, 1.0f);
        glEnable(GL_LIGHT2);
    } else {
        glDisable(GL_LIGHT1);
        glDisable(GL_LIGHT2);
    }

    // Car Taillights Logic
    if (player.taillightsOn) {
        GLfloat tailLightColor[] = { 0.8f, 0.0f, 0.0f, 1.0f }; // Red
        
        GLfloat tlPos1[] = { player.x - dirX * 2.0f - dirZ * 0.8f, player.y + 1.0f, player.z - dirZ * 2.0f + dirX * 0.8f, 1.0f };
        GLfloat tlPos2[] = { player.x - dirX * 2.0f + dirZ * 0.8f, player.y + 1.0f, player.z - dirZ * 2.0f - dirX * 0.8f, 1.0f };
        GLfloat tlDir[] = { -dirX, -0.4f, -dirZ }; // Pointing backwards and slightly down
        
        glLightfv(GL_LIGHT3, GL_POSITION, tlPos1);
        glLightfv(GL_LIGHT3, GL_SPOT_DIRECTION, tlDir);
        glLightfv(GL_LIGHT3, GL_DIFFUSE, tailLightColor);
        glLightf(GL_LIGHT3, GL_SPOT_CUTOFF, 45.0f);
        glLightf(GL_LIGHT3, GL_SPOT_EXPONENT, 2.0f);
        glLightf(GL_LIGHT3, GL_CONSTANT_ATTENUATION, 0.8f);
        glEnable(GL_LIGHT3);
        
        glLightfv(GL_LIGHT4, GL_POSITION, tlPos2);
        glLightfv(GL_LIGHT4, GL_SPOT_DIRECTION, tlDir);
        glLightfv(GL_LIGHT4, GL_DIFFUSE, tailLightColor);
        glLightf(GL_LIGHT4, GL_SPOT_CUTOFF, 45.0f);
        glLightf(GL_LIGHT4, GL_SPOT_EXPONENT, 2.0f);
        glLightf(GL_LIGHT4, GL_CONSTANT_ATTENUATION, 0.8f);
        glEnable(GL_LIGHT4);
    } else {
        glDisable(GL_LIGHT3);
        glDisable(GL_LIGHT4);
    }
}

// Main Display Function
void Display() {
    updateLighting();
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    // --- Camera Logic ---
    float camX, camY, camZ;
    float lookX, lookY, lookZ;
    float rad = player.rotY * PI / 180.0f;
    
    // Apply camera shake if active (collision effect)
    float shakeX = 0.0f, shakeY = 0.0f;
    if (cameraShakeDuration > 0.0f) {
        shakeX = (rand() % 100 - 50) / 50.0f * cameraShakeIntensity;
        shakeY = (rand() % 100 - 50) / 50.0f * cameraShakeIntensity;
    }

    if (cam.mode == 3 && mouseCaptured) { // Mouse Look Mode
        camX = player.x - cam.dist * sin(cam.yaw * PI / 180.0f) * cos(cam.pitch * PI / 180.0f) + shakeX;
        camY = player.y + cam.height + cam.dist * sin(cam.pitch * PI / 180.0f) + shakeY;
        camZ = player.z - cam.dist * cos(cam.yaw * PI / 180.0f) * cos(cam.pitch * PI / 180.0f);
        lookX = player.x;
        lookY = player.y + 2.0f;
        lookZ = player.z;
    } else if (cam.mode == 0) { // Third Person (Follow)
        camX = player.x - sin(rad) * cam.dist + shakeX;
        camZ = player.z - cos(rad) * cam.dist;
        camY = player.y + cam.height + shakeY;
        lookX = player.x;
        lookY = player.y + 2.0f;
        lookZ = player.z;
    } else if (cam.mode == 1) { // First Person (Driver View)
        camX = player.x + sin(rad) * 2.0f + shakeX; 
        camZ = player.z + cos(rad) * 2.0f;
        camY = player.y + 5.0f + shakeY;
        lookX = player.x + sin(rad) * 20.0f;
        lookY = player.y + 5.0f;
        lookZ = player.z + cos(rad) * 20.0f;
    } else { // Top Down View
        camX = player.x + shakeX;
        camZ = player.z;
        camY = player.y + 80.0f + shakeY;
        lookX = player.x;
        lookY = player.y;
        lookZ = player.z;
        gluLookAt(camX, camY, camZ, lookX, lookY, lookZ, sin(rad), 0, cos(rad));
        goto render;
    }

    gluLookAt(camX, camY, camZ, lookX, lookY, lookZ, 0, 1, 0);

render:
    drawEnvironment();

    // --- Draw Player Car ---
    glPushMatrix();
    glTranslatef(player.x, player.y, player.z);
    glRotatef(player.rotY + 180, 0, 1, 0); 
    
    // Draw Tires
    drawTire(1.2f, 0.5f, 1.2f);  // Front Right
    drawTire(-1.2f, 0.5f, 1.2f); // Front Left
    drawTire(1.2f, 0.5f, -1.2f); // Back Right
    drawTire(-1.2f, 0.5f, -1.2f);// Back Left

    // Draw Headlights/Taillights Visuals (Glowing Spheres)
    if (player.headlightsOn) {
        glDisable(GL_LIGHTING);
        glDisable(GL_TEXTURE_2D);
        glColor3f(1.0f, 1.0f, 0.8f); // Bright yellow/white
        
        // Headlight 1
        glPushMatrix();
        glTranslatef(1.0f, 0.2f, -5.0f); // Wider and adjusted Z
        glutSolidSphere(0.2, 10, 10);
        glPopMatrix();

        // Headlight 2
        glPushMatrix();
        glTranslatef(-1.0f, 0.2f, -5.0f);
        glutSolidSphere(0.2, 10, 10);
        glPopMatrix();
        
        glEnable(GL_LIGHTING);
    }

    if (player.taillightsOn) {
        glDisable(GL_LIGHTING);
        glDisable(GL_TEXTURE_2D);
        glColor3f(1.0f, 0.0f, 0.0f); // Bright red
        
        // Taillight 1
        glPushMatrix();
        glTranslatef(1.0f, 0.2f, 3.1f); // Wider and adjusted Z
        glutSolidSphere(0.2, 10, 10);
        glPopMatrix();

        // Taillight 2
        glPushMatrix();
        glTranslatef(-1.0f, 0.2f, 3.1f);
        glutSolidSphere(0.2, 10, 10);
        glPopMatrix();
        
        glEnable(GL_LIGHTING);
    }

    // Car Model Transformations
    glPushMatrix();
    glRotatef(-90, 1, 0, 0); 
    glScalef(1.2f, 1.2f, 1.2f); 
    
    // Set Car Color or Texture
    if (level == 2) {
        // Level 2: Blue textured car
        if (blueCarTexture != 0) {
            glEnable(GL_TEXTURE_2D);
            glBindTexture(GL_TEXTURE_2D, blueCarTexture);
            glColor3f(1.0f, 1.0f, 1.0f);

            // Automatic texture coordinate generation in object space
            glEnable(GL_TEXTURE_GEN_S);
            glEnable(GL_TEXTURE_GEN_T);
            glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
            glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
            // Map S to X and T to Z to get a reasonable projection
            GLfloat sPlane[] = { 0.5f, 0.0f, 0.0f, 0.0f }; // scale X
            GLfloat tPlane[] = { 0.0f, 0.0f, 0.5f, 0.0f }; // scale Z
            glTexGenfv(GL_S, GL_OBJECT_PLANE, sPlane);
            glTexGenfv(GL_T, GL_OBJECT_PLANE, tPlane);

            if (carDisplayList != 0) {
                glCallList(carDisplayList);
            } else {
                carModel.Draw();
            }

            // Cleanup
            glDisable(GL_TEXTURE_GEN_S);
            glDisable(GL_TEXTURE_GEN_T);
            glDisable(GL_TEXTURE_2D);
        } else {
            glColor3f(0.0f, 0.0f, 1.0f); // Fallback Blue Car
            if (carDisplayList != 0) {
                glCallList(carDisplayList);
            } else {
                carModel.Draw();
            }
        }
    } else {
        // Level 1: Red textured car (STL has no UVs -> use automatic texgen)
        if (carTexture != 0) {
            glEnable(GL_TEXTURE_2D);
            glBindTexture(GL_TEXTURE_2D, carTexture);
            glColor3f(1.0f, 1.0f, 1.0f);

            // Automatic texture coordinate generation in object space
            glEnable(GL_TEXTURE_GEN_S);
            glEnable(GL_TEXTURE_GEN_T);
            glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
            glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
            // Map S to X and T to Z to get a reasonable projection
            GLfloat sPlane[] = { 0.5f, 0.0f, 0.0f, 0.0f }; // scale X
            GLfloat tPlane[] = { 0.0f, 0.0f, 0.5f, 0.0f }; // scale Z
            glTexGenfv(GL_S, GL_OBJECT_PLANE, sPlane);
            glTexGenfv(GL_T, GL_OBJECT_PLANE, tPlane);

            if (carDisplayList != 0) {
                glCallList(carDisplayList);
            } else {
                carModel.Draw();
            }

            // Cleanup
            glDisable(GL_TEXTURE_GEN_S);
            glDisable(GL_TEXTURE_GEN_T);
            glDisable(GL_TEXTURE_2D);
        } else {
            // Fallback red color
            glColor3f(1.0f, 0.3f, 0.3f);
            if (carDisplayList != 0) {
                glCallList(carDisplayList);
            } else {
                carModel.Draw();
            }
        }
    }
    glPopMatrix();
    
    glPopMatrix();

    // --- Draw UI (Timer and Score) ---
    char timeStr[32];
    int minutes = timeRemaining / 60;
    int seconds = timeRemaining % 60;
    sprintf(timeStr, "Time: %02d:%02d", minutes, seconds);
    drawText(20, 730, timeStr);
    
    char scoreStr[32];
    sprintf(scoreStr, "Score: %d", score);
    drawText(20, 700, scoreStr);
    
    if (!raceStarted) {
        char startStr[32];
        if (trafficLightState == 0) sprintf(startStr, "READY... (RED)");
        else if (trafficLightState == 1) sprintf(startStr, "SET... (YELLOW)");
        else sprintf(startStr, "GO! (GREEN)");
        drawText(450, 600, startStr, GLUT_BITMAP_TIMES_ROMAN_24);
    }
    
    drawText(20, 670, "Controls: WASD to Drive | H: Headlights | J: Taillights | Right Click: Camera");

    // Game Over Screen
    if (gameOver) {
        glDisable(GL_LIGHTING);
        glDisable(GL_DEPTH_TEST);
        glColor3f(0.0f, 0.0f, 0.0f);
        
        drawText(450, 400, "YOU LOST!", GLUT_BITMAP_TIMES_ROMAN_24);
        drawText(430, 370, "Time ran out.", GLUT_BITMAP_TIMES_ROMAN_24);
        drawText(380, 340, "Press ENTER to restart.", GLUT_BITMAP_TIMES_ROMAN_24);
        
        glEnable(GL_DEPTH_TEST);
        glEnable(GL_LIGHTING);
    }

    // Level Won Screen
    if (levelWon) {
        glDisable(GL_LIGHTING);
        glDisable(GL_DEPTH_TEST);
        
        char winStr[64];
        if (level == 2) {
            sprintf(winStr, "YOU WON THE GAME!");
        } else {
            sprintf(winStr, "YOU WON LEVEL %d!", level);
        }
        drawText(400, 450, winStr, GLUT_BITMAP_TIMES_ROMAN_24);
        
        char scoreMsg[64];
        sprintf(scoreMsg, "Score: %d", score); 
        drawText(380, 400, scoreMsg, GLUT_BITMAP_TIMES_ROMAN_24);
        
        if (level == 2) {
            drawText(330, 350, "Press ENTER to restart", GLUT_BITMAP_TIMES_ROMAN_24);
        } else {
            drawText(330, 350, "Press ENTER to enter the next level", GLUT_BITMAP_TIMES_ROMAN_24);
        }
        
        glEnable(GL_DEPTH_TEST);
        glEnable(GL_LIGHTING);
    }

    glutSwapBuffers();
}

// Timer Function - Handles Physics, Game Logic, and Animations
void Timer(int value) {
    int currentTime = glutGet(GLUT_ELAPSED_TIME);
    int elapsedTime = currentTime - raceStartTime;

    // --- Traffic Light Logic ---
    if (!raceStarted) {
        if (elapsedTime < 7000) trafficLightState = 0; // Red (Extended to 7s)
        else if (elapsedTime < 10000) trafficLightState = 1; // Yellow (3s)
        else {
            trafficLightState = 2; // Green
            raceStarted = true;
            lastTime = currentTime; // Start game timer
        }
    } else {
        // --- Game Timer Logic ---
        if (currentTime - lastTime >= 1000) {
            if (timeRemaining > 0) timeRemaining--;
            else if (!gameOver && !levelWon) {
                gameOver = true;
                if (!playedLoseSound) {
                    // Stop all other sounds to prevent stuttering/overlap
                    mciSendStringA("stop revving", NULL, 0, NULL);
                    mciSendStringA("stop engine", NULL, 0, NULL);
                    mciSendStringA("stop crash", NULL, 0, NULL);
                    mciSendStringA("stop eat_cake", NULL, 0, NULL);
                    mciSendStringA("stop collect_gummy", NULL, 0, NULL);
                    
                    mciSendStringA("play lose from 0", NULL, 0, NULL);
                    playedLoseSound = true;
                }
                isDriving = false;
            }
            lastTime = currentTime;
        }
    }

    // --- Check Finish Line ---
    if (raceStarted && !gameOver && !levelWon && player.z < FINISH_LINE_Z) {
        levelWon = true;
        if (!playedWinSound) {
            // Stop all other sounds
            mciSendStringA("stop revving", NULL, 0, NULL);
            mciSendStringA("stop engine", NULL, 0, NULL);
            mciSendStringA("stop crash", NULL, 0, NULL);
            mciSendStringA("stop eat_cake", NULL, 0, NULL);
            mciSendStringA("stop collect_gummy", NULL, 0, NULL);
            
            mciSendStringA("play win from 0", NULL, 0, NULL);
            playedWinSound = true;
        }
        isDriving = false;
        
        // Bounce effect (simple jump)
        player.y += 2.0f; 
    }

    if (gameOver || levelWon) {
        glutPostRedisplay();
        glutTimerFunc(16, Timer, 0);
        return; // Stop physics updates
    }

    // --- Physics Update ---
    float currentMaxSpeed = MAX_SPEED;
    // Check if speed boost is active
    if (currentTime < speedBoostEndTime) {
        currentMaxSpeed = MAX_SPEED * SPEED_BOOST_MULTIPLIER;
    }

    // Check shield expiration
    if (shieldActive &&  currentTime > shieldEndTime) {
        shieldActive = false;
        printf("Shield expired!\n");
    }
    
    if (raceStarted) {
        if (keyState['w'] || keyState['W']) player.speed += ACCELERATION;
        else if (keyState['s'] || keyState['S']) player.speed -= ACCELERATION;
        else player.speed *= DECELERATION; // Friction
    } else {
        player.speed = 0; // Can't move yet
    }

    // --- Sound Logic ---
    if (!raceStarted && (keyState['w'] || keyState['W'])) {
        if (!isRevving) {
            mciSendStringA("play revving from 0", NULL, 0, NULL);
            isRevving = true;
        }
    } else {
        isRevving = false;
        mciSendStringA("stop revving", NULL, 0, NULL);
    }

    if (raceStarted && fabs(player.speed) > 0.1f) {
        if (!isDriving) {
            mciSendStringA("play engine repeat", NULL, 0, NULL);
            isDriving = true;
        }
    } else {
        isDriving = false;
        mciSendStringA("stop engine", NULL, 0, NULL);
    }

    // Cap Speed (with boost consideration)
    if (player.speed > currentMaxSpeed) player.speed = currentMaxSpeed;
    if (player.speed < -currentMaxSpeed / 2) player.speed = -currentMaxSpeed / 2;
    
    // --- Animations ---
    // Update cake rotation
    for (auto& cake : cakes) {
        if (cake.active) {
            cake.rot += 2.0f; // Rotate for animation
            if (cake.rot > 360.0f) cake.rot -= 360.0f;
        }
    }
    
    // Update gummy bobbing animation
    float time = currentTime / 1000.0f; // Convert to seconds
    for (auto& gummy : gummies) {
        if (gummy.active) {
            gummy.bobbingOffset = sin(time * 3.0f) * 0.3f; // Bobbing up and down
        }
    }

    // Update candy cane bobbing animation (Level 2)
    for (auto& candy : candyCanes) {
        if (candy.active) {
            candy.bobbingOffset = sin(time * 3.0f) * 0.3f; // Bobbing up and down
        }
    }
    
    // Update ice cream cart rotation
    for (auto& cart : obstacles) {
        if (cart.active) {
            cart.rot += 1.0f; // Rotate slowly
            if (cart.rot > 360.0f) cart.rot -= 360.0f;
        }
    }

    // Update gumball machine rotation
    for (auto& machine : gumballs) {
        if (machine.active) {
            machine.rot += 1.5f; // Rotate slightly faster
            if (machine.rot > 360.0f) machine.rot -= 360.0f;
        }
    }
    
    // --- Collision Detection ---
    
    // Check cake collision
    for (auto& cake : cakes) {
        if (cake.active) {
            float dx = player.x - cake.x;
            float dz = player.z - cake.z;
            float distance = sqrt(dx * dx + dz * dz);
            
            if (distance < 5.0f) { // Collision radius
                cake.active = false;
                if (level == 1) {
                    // Speed boost in Level 1
                    speedBoostEndTime = currentTime + (SPEED_BOOST_DURATION * 1000);
                    mciSendStringA("play eat_cake from 0", NULL, 0, NULL);
                    printf("Cake collected! Speed boost activated!\n");
                } else if (level == 2) {
                    // Shield in Level 2
                    shieldActive = true;
                    shieldEndTime = currentTime + (SHIELD_DURATION * 1000);
                    mciSendStringA("play shield from 0", NULL, 0, NULL);
                    printf("Cake pop collected! Shield activated!\n");
                }
            }
        }
    }
    
    // Check gummy collision
    for (auto& gummy : gummies) {
        if (gummy.active) {
            float dx = player.x - gummy.x;
            float dz = player.z - gummy.z;
            float distance = sqrt(dx * dx + dz * dz);
            
            if (distance < 3.0f) { // Collision radius
                gummy.active = false;
                score += 30;
                mciSendStringA("play collect_gummy from 0", NULL, 0, NULL);
                printf("Gummy collected! Score: %d\n", score);
            }
        }
    }
    
    // Check obstacle collision
    for (auto& cart : obstacles) {
        if (cart.active) {
            float dx = player.x - cart.x;
            float dz = player.z - cart.z;
            float distance = sqrt(dx * dx + dz * dz);
            
            if (distance < 6.0f) { // Collision radius for cart
                if (currentTime < invincibilityEndTime) {
                    // Grace period - do nothing
                } else if (!shieldActive) {
                    // Only apply damage if shield is not active
                    // Bounce back based on direction relative to obstacle
                    float playerDirX = sin(player.rotY * PI / 180.0f);
                    float playerDirZ = cos(player.rotY * PI / 180.0f);
                    float dot = dx * playerDirX + dz * playerDirZ;
                    
                    if (dot > 0) player.speed = 0.8f; // Move forward (away)
                    else player.speed = -0.8f; // Move backward (away)
                    
                    // Trigger camera shake (brief but quick)
                    cameraShakeIntensity = 2.0f; // Higher intensity
                    cameraShakeDuration = 150.0f; // Short duration (150ms)
                    
                    // Play crash sound
                    mciSendStringA("play crash from 0", NULL, 0, NULL);
                    printf("Hit ice cream cart!\n");
                } else {
                    printf("Shield protected you from ice cream cart!\n");
                    shieldActive = false; // Shield used up
                    invincibilityEndTime = currentTime + 4000; // 4 seconds grace period
                }
            }
        }
    }

    // Check gumball machine collision (Level 2)
    if (level == 2) {
        for (auto& machine : gumballs) {
            if (machine.active) {
                float dx = player.x - machine.x;
                float dz = player.z - machine.z;
                float distance = sqrt(dx * dx + dz * dz);
                
                if (distance < 6.0f) { // Collision radius
                    if (currentTime < invincibilityEndTime) {
                        // Grace period - do nothing
                    } else if (!shieldActive) {
                        // Only apply damage if shield is not active
                        // Bounce back based on direction relative to obstacle
                        float playerDirX = sin(player.rotY * PI / 180.0f);
                        float playerDirZ = cos(player.rotY * PI / 180.0f);
                        float dot = dx * playerDirX + dz * playerDirZ;
                        
                        if (dot > 0) player.speed = 0.8f; // Move forward (away)
                        else player.speed = -0.8f; // Move backward (away)
                        
                        cameraShakeIntensity = 2.0f;
                        cameraShakeDuration = 150.0f;
                        
                        mciSendStringA("play crash from 0", NULL, 0, NULL);
                        printf("Hit gumball machine!\n");
                    } else {
                        printf("Shield protected you from gumball machine!\n");
                        shieldActive = false; // Shield used up
                        invincibilityEndTime = currentTime + 4000; // 4 seconds grace period
                    }
                }
            }
        }
    }

    // Check candy cane collision (Level 2)
    if (level == 2) {
        for (auto& candy : candyCanes) {
            if (candy.active) {
                float dx = player.x - candy.x;
                float dz = player.z - candy.z;
                float distance = sqrt(dx * dx + dz * dz);
                
                if (distance < 3.0f) { // Collision radius
                    candy.active = false;
                    score += 30;
                    mciSendStringA("play collect_gummy from 0", NULL, 0, NULL);
                    printf("Candy cane collected! Score: %d\n", score);
                }
            }
        }
    }
    
    // Update camera shake
    if (cameraShakeDuration > 0.0f) {
        cameraShakeDuration -= 16.0f; // Decrease by frame time
        if (cameraShakeDuration <= 0.0f) {
            cameraShakeDuration = 0.0f;
            cameraShakeIntensity = 0.0f;
        }
    }

    // Steering (only when moving)
    if (fabs(player.speed) > 0.01f) {
        if (keyState['a'] || keyState['A']) player.rotY += TURN_SPEED * (player.speed > 0 ? 1 : -1);
        if (keyState['d'] || keyState['D']) player.rotY -= TURN_SPEED * (player.speed > 0 ? 1 : -1);
    }

    // Move Car
    player.x += sin(player.rotY * PI / 180.0f) * player.speed;
    player.z += cos(player.rotY * PI / 180.0f) * player.speed;

    glutPostRedisplay();
    glutTimerFunc(16, Timer, 0);
}

// Keyboard Input Handler
void Keyboard(unsigned char key, int x, int y) {
    if (gameOver || levelWon) {
        if (key == 13) { // Enter Key
            if (levelWon) {
                if (level == 2) level = 1; // Restart game after level 2
                else level++; // Go to next level
            }
            
            // Reset Game State
            gameOver = false;
            levelWon = false;
            playedLoseSound = false;
            playedWinSound = false;
            timeRemaining = GAME_DURATION;
            score = 0;
            player.x = 0;
            player.y = 1.0f;
            player.z = 25.0f;
            player.speed = 0;
            player.rotY = 180;
            player.wheelRot = 0;
            
            shieldActive = false;
            shieldEndTime = 0;
            
            raceStarted = false;
            trafficLightState = 0;
            raceStartTime = glutGet(GLUT_ELAPSED_TIME);
            
            // Reset obstacles/collectibles
            for (auto& cake : cakes) cake.active = true;
            for (auto& gummy : gummies) gummy.active = true;
            for (auto& cart : obstacles) cart.active = true;
            for (auto& machine : gumballs) machine.active = true;
            for (auto& candy : candyCanes) candy.active = true;
            
            // Clear Level 1 obstacles if in Level 2
            if (level == 2) {
                for (auto& cart : obstacles) cart.active = false; // Disable ice cream carts in level 2
            } else {
                for (auto& machine : gumballs) machine.active = false; // Disable gumballs in level 1
            }
            
            mciSendStringA("stop lose", NULL, 0, NULL);
            mciSendStringA("stop win", NULL, 0, NULL);
        }
        return;
    }

    keyState[key] = true;
    if (key == 'h' || key == 'H') {
        player.headlightsOn = !player.headlightsOn;
        printf("Headlights: %s\n", player.headlightsOn ? "ON" : "OFF");
    }
    if (key == 'j' || key == 'J') {
        player.taillightsOn = !player.taillightsOn;
        printf("Taillights: %s\n", player.taillightsOn ? "ON" : "OFF");
    }
    if (key == 27) { // ESC Key
        if (mouseCaptured) {
            mouseCaptured = false;
            glutSetCursor(GLUT_CURSOR_INHERIT);
        } else {
            exit(0);
        }
    }
}

// Keyboard Up Handler
void KeyboardUp(unsigned char key, int x, int y) {
    keyState[key] = false;
}

// Mouse Click Handler
void Mouse(int button, int state, int x, int y) {
    if (button == GLUT_RIGHT_BUTTON && state == GLUT_DOWN) {
        cam.mode = (cam.mode + 1) % 4; // Cycle through 4 camera modes
        printf("Camera Mode: %d\n", cam.mode);
        
        if (cam.mode == 3) { // Mouse Look Mode
            mouseCaptured = true;
            glutSetCursor(GLUT_CURSOR_NONE);
            cam.yaw = player.rotY;
            cam.pitch = 20.0f;
            lastMouseX = x;
            lastMouseY = y;
        } else {
            mouseCaptured = false;
            glutSetCursor(GLUT_CURSOR_INHERIT);
        }
    }
}

// Mouse Motion Handler (for Camera Look)
void MouseMotion(int x, int y) {
    if (mouseCaptured) {
        int dx = x - lastMouseX;
        int dy = y - lastMouseY;
        
        cam.yaw += dx * 0.2f;
        cam.pitch += dy * 0.2f;
        
        // Clamp pitch to avoid flipping
        if (cam.pitch > 89.0f) cam.pitch = 89.0f;
        if (cam.pitch < -10.0f) cam.pitch = -10.0f;
        
        lastMouseX = x;
        lastMouseY = y;
        
        // Keep mouse centered to prevent hitting screen edges
        if (x < 100 || x > 900 || y < 100 || y > 600) {
            glutWarpPointer(1024/2, 768/2);
            lastMouseX = 1024/2;
            lastMouseY = 768/2;
        }
    }
}

// Main Entry Point
int main(int argc, char** argv) {
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
    glutInitWindowSize(1024, 768);
    glutInitWindowPosition(100, 100);
    glutCreateWindow("Candy Land: Sugar Rush");

    Init(); // Initialize game state and resources

    glutDisplayFunc(Display);
    glutKeyboardFunc(Keyboard);
    glutKeyboardUpFunc(KeyboardUp);
    glutMouseFunc(Mouse);
    glutPassiveMotionFunc(MouseMotion);
    glutTimerFunc(0, Timer, 0);
    
    // Setup Projection Matrix
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(60.0, 1024.0/768.0, 0.1, 2000.0); // Increased draw distance
    glMatrixMode(GL_MODELVIEW);

    glutMainLoop(); // Enter GLUT event loop
    return 0;
}
